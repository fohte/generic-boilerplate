#!/usr/bin/env bash
#
# Apply Renovate changes from generated/ to template/
#
# Usage:
#   scripts/apply-renovate-patch [base_ref]
#
# Arguments:
#   base_ref: The base branch/ref to compare against (default: origin/master)
#
# Exit codes:
#   0: Success (versions synced or no changes)
#   1: Some files could not be synced
#
# Tests:
#   See apply-renovate-patch.bats (run with: bats scripts/apply-renovate-patch.bats)

set -euo pipefail

BASE_REF="${1:-origin/master}"

YIELD_DIR="template/{% yield pkg from subpackages %}{{ pkg.name }}{% endyield %}"

# Get the subpackage type from fixture YAML.
# Usage: get_subpackage_type <fixture> <subpackage_name>
# Returns the type (e.g., "node", "rust") via stdout.
get_subpackage_type() {
  local fixture="$1"
  local subpkg="$2"
  local fixture_file="tests/fixtures/${fixture}.yml"

  if [[ ! -f "$fixture_file" ]]; then
    return 1
  fi

  local pkg_type
  pkg_type=$(yq ".subpackages[] | select(.name == \"${subpkg}\") | .type" "$fixture_file" 2> /dev/null)

  if [[ -z "$pkg_type" || "$pkg_type" == "null" ]]; then
    return 1
  fi

  echo "$pkg_type"
}

# Resolve a file inside the yield directory to its conditional template path.
# Usage: resolve_yield_template <filename> <pkg_type>
# Returns the full template path via stdout.
resolve_yield_template() {
  local filename="$1"
  local pkg_type="$2"
  local yield_dir="$YIELD_DIR"

  # Try exact conditional filename with .jinja extension
  local conditional_jinja="${yield_dir}/{% if pkg.type == '${pkg_type}' %}${filename}{% endif %}.jinja"
  if [[ -f "$conditional_jinja" ]]; then
    echo "$conditional_jinja"
    return 0
  fi

  # Try exact conditional filename without .jinja
  local conditional="${yield_dir}/{% if pkg.type == '${pkg_type}' %}${filename}{% endif %}"
  if [[ -f "$conditional" ]]; then
    echo "$conditional"
    return 0
  fi

  # Try multi-type conditional (e.g., {% if pkg.type in ['node', 'rust'] %})
  local found
  found=$(find "$yield_dir" -maxdepth 1 -name "*${filename}*" -not -name "*.jinja" 2> /dev/null | head -1)
  if [[ -n "$found" && -f "$found" ]]; then
    echo "$found"
    return 0
  fi
  found=$(find "$yield_dir" -maxdepth 1 -name "*${filename}*.jinja" 2> /dev/null | head -1)
  if [[ -n "$found" && -f "$found" ]]; then
    echo "$found"
    return 0
  fi

  # Try subdirectories (e.g., .sg/rules/no-assert-contains.yml)
  if [[ "$filename" == */* ]]; then
    local subdir="${filename%/*}"
    local base="${filename##*/}"
    # Look for conditional subdirectory
    local found_sub
    found_sub=$(find "$yield_dir" -path "*${subdir}*" -name "${base}" 2> /dev/null | head -1)
    if [[ -n "$found_sub" && -f "$found_sub" ]]; then
      echo "$found_sub"
      return 0
    fi
    found_sub=$(find "$yield_dir" -path "*${subdir}*" -name "${base}.jinja" 2> /dev/null | head -1)
    if [[ -n "$found_sub" && -f "$found_sub" ]]; then
      echo "$found_sub"
      return 0
    fi
  fi

  return 1
}

# Sync versions from generated file to template.
# For each line with a version in the generated file, update the corresponding
# line in the template to use the same version.
sync_versions_to_template() {
  local generated_file="$1"
  local template_file="$2"
  local changes_applied=0
  local keys_checked=0

  while IFS= read -r line; do
    # Match version patterns:
    # - TOML: key = "version" or "key" = "version"
    # - JSON: "key": "version"
    # - YAML: key: version or key: vX.Y.Z (unquoted, with optional v prefix)
    # - GitHub Actions: uses: owner/repo@vX.Y.Z
    # Semver range specifiers: =, ^, ~, >, >=, <, <= (for Cargo.toml pin, npm ranges)
    if [[ "$line" =~ ^[[:space:]]*-?[[:space:]]*(uses:[[:space:]]*[^@]+)@(v?[0-9]+(\.[0-9]+)*[^[:space:]#]*) ]]; then
      # GitHub Actions uses: directive - version after @
      local key="${BASH_REMATCH[1]}"
      local version="${BASH_REMATCH[2]}"
      local quoted=false
      local uses_syntax=true
    elif [[ "$line" =~ ^[[:space:]]*(\"[^\"]+\"|[^[:space:]=:]+)[[:space:]]*[=:][[:space:]]*\"([=^~\>\<]{0,2}v?[0-9]+\.[0-9]+[^\"]*)\" ]]; then
      # Quoted version (TOML/JSON) - includes semver range specifiers
      local key="${BASH_REMATCH[1]}"
      local version="${BASH_REMATCH[2]}"
      local quoted=true
      local uses_syntax=false
    elif [[ "$line" =~ ^[[:space:]]*(\"[^\"]+\"|[^[:space:]=:]+)[[:space:]]*:[[:space:]]*([=^~\>\<]{0,2}v?[0-9]+\.[0-9]+[^[:space:]#]*) ]]; then
      # Unquoted version (YAML) - only match colon separator, includes semver range specifiers
      local key="${BASH_REMATCH[1]}"
      local version="${BASH_REMATCH[2]}"
      local quoted=false
      local uses_syntax=false
    else
      continue
    fi

    # Check if template has this key
    if grep -Fq -- "$key" "$template_file" 2> /dev/null; then
      ((keys_checked++)) || true
      # Skip if version already matches
      if [[ "$uses_syntax" == "true" ]]; then
        # GitHub Actions uses: syntax - version after @
        local escaped_version
        escaped_version=$(printf '%s' "$version" | sed 's/[].[^$*+?(){}|\\]/\\&/g')
        if grep -F -- "$key" "$template_file" | grep -Eq "@${escaped_version}([[:space:]]|#|$)"; then
          continue
        fi
        # Replace version for this key in template (match @version pattern)
        # Escape regex metacharacters and sed delimiter (#) in key
        local escaped_key
        escaped_key=$(printf '%s' "$key" | sed 's/[#.^$*[\\/]/\\&/g')
        # Escape sed replacement special characters (& and \) and delimiter (#) in version
        local escaped_version_sed
        escaped_version_sed=$(printf '%s' "$version" | sed 's/[#\\&]/\\&/g')
        if sed -i.bak "s#\\(${escaped_key}@\\)[^[:space:]#]*#\\1${escaped_version_sed}#" "$template_file"; then
          rm -f "${template_file}.bak"
          ((changes_applied++)) || true
        fi
      elif [[ "$quoted" == "true" ]]; then
        if grep -F -- "$key" "$template_file" | grep -Fq "\"${version}\""; then
          continue
        fi
        # Replace version for this key in template (match quoted version string)
        if sed -i.bak "s#\\(${key}[[:space:]]*[=:][[:space:]]*\"\\)[^\"]*\\(\".*\\)#\\1${version}\\2#" "$template_file"; then
          rm -f "${template_file}.bak"
          ((changes_applied++)) || true
        fi
      else
        # Use fixed string matching to avoid regex interpretation of version specifiers like ^
        # Group grep commands to avoid running the first grep twice, and ensure exact match
        # by checking for trailing whitespace, comment, or end of line
        if grep -F -- "$key" "$template_file" | grep -Eq ":[[:space:]]*$(printf '%s' "$version" | sed 's/[].[^$*+?(){}|\\]/\\&/g')([[:space:]]|#|$)"; then
          continue
        fi
        # Replace version for this key in template (match unquoted version)
        if sed -i.bak "s#\\(${key}[[:space:]]*:[[:space:]]*\\)[^[:space:]#]*#\\1${version}#" "$template_file"; then
          rm -f "${template_file}.bak"
          ((changes_applied++)) || true
        fi
      fi
    fi
  done < "$generated_file"

  if [[ $changes_applied -gt 0 ]]; then
    echo "    Synced $changes_applied version(s)"
  elif [[ $keys_checked -gt 0 ]]; then
    echo "    Already in sync"
  fi
  # Return success if any keys were found (even if already in sync)
  [[ $keys_checked -gt 0 ]]
}

# Exclude files from version syncing. Patterns are grep regex, anchored to end of filename.
excludes=(
  '\.copier-answers\.yml$' # Not a source file
  'bun\.lock$'             # Copied directly in workflow (not version-synced to template)
  'Cargo\.lock$'           # Regenerated by cargo generate-lockfile in workflow (version key is too generic)
)
grep_opts=()
for ex in "${excludes[@]}"; do
  grep_opts+=(-e "$ex")
done

# Get changed files in generated/ (Renovate's changes)
changed=$(git diff --name-only "${BASE_REF}" HEAD -- 'generated/' | grep -v "${grep_opts[@]}" || true)

if [[ -z "$changed" ]]; then
  echo "No files changed in generated/"
  exit 0
fi

echo "Changed files in generated/:"
echo "$changed"
echo ""

applied_files=()
failed_files=()

while IFS= read -r generated_file; do
  template_file=""

  # Count path depth: generated/<fixture>/<file> (3) vs generated/<fixture>/<subpkg>/<file> (4+)
  depth=$(echo "$generated_file" | tr '/' '\n' | wc -l)

  if [[ $depth -ge 4 ]]; then
    # Potential monorepo subpackage: generated/<fixture>/<subpkg>/<file>
    fixture=$(echo "$generated_file" | cut -d/ -f2)
    subpkg=$(echo "$generated_file" | cut -d/ -f3)
    # Everything after generated/<fixture>/<subpkg>/
    subpkg_file=$(echo "$generated_file" | cut -d/ -f4-)

    # Try to resolve as a yield subpackage first
    pkg_type=""
    if pkg_type=$(get_subpackage_type "$fixture" "$subpkg"); then
      template_file=$(resolve_yield_template "$subpkg_file" "$pkg_type" 2> /dev/null) || true
    fi
  fi

  # Fallback: root-level template resolution (original logic)
  if [[ -z "$template_file" ]]; then
    # Extract relative path (e.g., generated/base/package.json -> package.json)
    rel_path=${generated_file#*/*/}

    if [[ -f "template/${rel_path}.jinja" ]]; then
      template_file="template/${rel_path}.jinja"
    elif [[ -f "template/${rel_path}" ]] && [[ ! -L "template/${rel_path}" ]]; then
      template_file="template/${rel_path}"
    elif [[ -L "template/${rel_path}" ]]; then
      template_file=$(realpath -m --relative-to=. "template/${rel_path}")
    fi
  fi

  if [[ -z "$template_file" ]]; then
    echo "Warning: No template file found for $generated_file"
    continue
  fi

  echo "Processing: $generated_file -> $template_file"

  if sync_versions_to_template "$generated_file" "$template_file"; then
    applied_files+=("$template_file")
  else
    failed_files+=("$generated_file -> $template_file")
  fi
done <<< "$changed"

echo ""

# Report results
if [[ ${#applied_files[@]} -gt 0 ]]; then
  echo "Successfully synced files:"
  for f in "${applied_files[@]}"; do
    echo "  - $f"
  done
fi

if [[ ${#failed_files[@]} -gt 0 ]]; then
  echo ""
  echo "Files requiring manual update:"
  for f in "${failed_files[@]}"; do
    echo "  - $f"
  done
  exit 1
fi

echo ""
echo "Done."
