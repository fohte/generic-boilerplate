#!/usr/bin/env bash
#
# Generate template snapshots from fixture data files.
#
# Usage:
#   scripts/generate-snapshots                                  # Regenerate all fixtures into generated/
#   scripts/generate-snapshots --fixture <name> --output <dir>  # Generate a single fixture to a custom directory
#
# In bulk mode (no arguments), each generated/<fixture> directory is overwritten
# in place. Files listed in copier.yml _skip_if_exists (e.g. lockfiles) are
# automatically preserved by copier, and files no longer produced by the
# template are removed. In single-fixture mode, the output directory is used
# as-is (the caller is responsible for cleanup).

set -euo pipefail

# Use copier directly if available, otherwise fall back to pipx run
if command -v copier > /dev/null 2>&1; then
  COPIER_CMD="copier"
else
  COPIER_CMD="pipx run copier"
fi

# Generate a single fixture snapshot.
# All paths are relative to the current working directory.
# Arguments:
#   $1 - fixture name (corresponds to tests/fixtures/<name>.yml)
#   $2 - output directory
generate_fixture() {
  local fixture=$1
  local output_dir=$2

  $COPIER_CMD copy --trust --overwrite --data-file "tests/fixtures/$fixture.yml" . "$output_dir"

  # Remove answers file as it contains a commit hash that changes on every run
  rm -f "$output_dir/.copier-answers.yml"
}

# Remove files that the template no longer produces (stale files).
# Generates into a clean temporary directory and deletes any file in
# output_dir that does not appear in the clean output.
# Arguments:
#   $1 - fixture name
#   $2 - output directory
remove_stale_files() {
  local fixture=$1
  local output_dir=$2

  local tmpdir
  tmpdir=$(mktemp -d)
  trap 'rm -rf "$tmpdir"' RETURN

  $COPIER_CMD copy --trust --overwrite --data-file "tests/fixtures/$fixture.yml" . "$tmpdir"
  rm -f "$tmpdir/.copier-answers.yml"

  while IFS= read -r -d '' file; do
    local rel_path="${file#"$output_dir"/}"
    if [[ ! -e "$tmpdir/$rel_path" ]]; then
      rm -f "$file"
    fi
  done < <(find "$output_dir" -type f -print0)

  # Clean up empty directories left behind
  find "$output_dir" -type d -empty -delete 2> /dev/null || true
}

# Parse arguments
fixture=""
output_dir=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --fixture)
      if [[ -z "${2-}" ]]; then
        echo "Error: missing argument for $1" >&2
        exit 1
      fi
      fixture=$2
      shift 2
      ;;
    --output)
      if [[ -z "${2-}" ]]; then
        echo "Error: missing argument for $1" >&2
        exit 1
      fi
      output_dir=$2
      shift 2
      ;;
    *)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
  esac
done

if [[ -n "$fixture" && -n "$output_dir" ]]; then
  # Single fixture mode
  generate_fixture "$fixture" "$output_dir"
elif [[ -z "$fixture" && -z "$output_dir" ]]; then
  # Bulk mode: regenerate all fixtures
  shopt -s nullglob
  for data_file in tests/fixtures/*.yml; do
    fixture=$(basename "$data_file" .yml)
    echo "Generating: $fixture"

    generate_fixture "$fixture" "generated/$fixture"
    remove_stale_files "$fixture" "generated/$fixture"
  done
else
  echo "Error: --fixture and --output must be specified together" >&2
  exit 1
fi
