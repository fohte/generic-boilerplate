#!/usr/bin/env bash
#
# Generate template snapshots from fixture data files.
#
# Usage:
#   scripts/generate-snapshots                                  # Regenerate all fixtures into generated/
#   scripts/generate-snapshots --fixture <name> --output <dir>  # Generate a single fixture to a custom directory
#
# In bulk mode (no arguments), each generated/<fixture> directory is removed and
# recreated from scratch, but lockfiles (matching copier.yml _skip_if_exists
# patterns) are preserved across regeneration to avoid reverting Renovate updates.
# In single-fixture mode, the output directory is used as-is (the caller is
# responsible for cleanup).

set -euo pipefail

# Use copier directly if available, otherwise fall back to pipx run
if command -v copier > /dev/null 2>&1; then
  COPIER_CMD="copier"
else
  COPIER_CMD="pipx run copier"
fi

# Lockfile patterns to preserve during bulk regeneration.
# Keep in sync with _skip_if_exists in copier.yml.
LOCKFILE_PATTERNS=(
  "bun.lock"
  "Cargo.lock"
  "*/bun.lock"
  "*/Cargo.lock"
)

# Save lockfiles from the output directory to a temporary directory.
# Arguments:
#   $1 - output directory to save lockfiles from
#   $2 - temporary directory to save lockfiles to
save_lockfiles() {
  local output_dir=$1
  local tmp_dir=$2

  for pattern in "${LOCKFILE_PATTERNS[@]}"; do
    # Use find for glob expansion within the output directory
    while IFS= read -r -d '' file; do
      local rel_path="${file#"$output_dir"/}"
      local dest="$tmp_dir/$rel_path"
      mkdir -p "$(dirname "$dest")"
      cp "$file" "$dest"
    done < <(find "$output_dir" -path "$output_dir/$pattern" -print0 2> /dev/null)
  done
}

# Restore lockfiles from the temporary directory to the output directory.
# Arguments:
#   $1 - temporary directory containing saved lockfiles
#   $2 - output directory to restore lockfiles to
restore_lockfiles() {
  local tmp_dir=$1
  local output_dir=$2

  if [[ ! -d "$tmp_dir" ]]; then
    return
  fi

  # Find all saved lockfiles and restore them
  while IFS= read -r -d '' file; do
    local rel_path="${file#"$tmp_dir"/}"
    local dest="$output_dir/$rel_path"
    mkdir -p "$(dirname "$dest")"
    cp "$file" "$dest"
  done < <(find "$tmp_dir" -type f -print0 2> /dev/null)
}

# Generate a single fixture snapshot.
# All paths are relative to the current working directory.
# Arguments:
#   $1 - fixture name (corresponds to tests/fixtures/<name>.yml)
#   $2 - output directory
generate_fixture() {
  local fixture=$1
  local output_dir=$2

  $COPIER_CMD copy --trust --data-file "tests/fixtures/$fixture.yml" . "$output_dir"

  # Remove answers file as it contains a commit hash that changes on every run
  rm -f "$output_dir/.copier-answers.yml"
}

# Parse arguments
fixture=""
output_dir=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --fixture)
      if [[ -z "${2-}" ]]; then
        echo "Error: missing argument for $1" >&2
        exit 1
      fi
      fixture=$2
      shift 2
      ;;
    --output)
      if [[ -z "${2-}" ]]; then
        echo "Error: missing argument for $1" >&2
        exit 1
      fi
      output_dir=$2
      shift 2
      ;;
    *)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
  esac
done

if [[ -n "$fixture" && -n "$output_dir" ]]; then
  # Single fixture mode
  generate_fixture "$fixture" "$output_dir"
elif [[ -z "$fixture" && -z "$output_dir" ]]; then
  # Bulk mode: regenerate all fixtures
  shopt -s nullglob
  for data_file in tests/fixtures/*.yml; do
    fixture=$(basename "$data_file" .yml)
    echo "Generating: $fixture"

    # Save lockfiles before removing the directory so that copier's
    # _skip_if_exists can preserve them (the files must exist for the
    # skip logic to trigger).
    lockfile_tmp=$(mktemp -d)
    save_lockfiles "generated/$fixture" "$lockfile_tmp"

    rm -rf "generated/$fixture"
    generate_fixture "$fixture" "generated/$fixture"

    restore_lockfiles "$lockfile_tmp" "generated/$fixture"
    rm -rf "$lockfile_tmp"
  done
else
  echo "Error: --fixture and --output must be specified together" >&2
  exit 1
fi
