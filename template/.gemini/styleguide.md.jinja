{%- set has_rust = (type == 'rust') or (subpackages | selectattr('type', 'equalto', 'rust') | list | length > 0) -%}
# Gemini Code Assist Style Guide

## DO NOT suggest

- Changing versions or editions specified in config files

Assume version choices are intentional. Your training data may be outdated.
{% if has_rust %}

## Test code review rules

### Parameterize similar test cases with rstest

When multiple Rust test functions share the same assertion logic and differ only in input/expected values, they should be consolidated into a single parameterized test using `#[rstest]` with `#[case]`.

Signs of violation:

- Two or more test functions with nearly identical bodies, differing only in literals
- Copy-pasted test logic with minor variations

Before (bad):

```rust
#[test]
fn test_parse_empty() {
    assert_eq!(parse(""), None);
}

#[test]
fn test_parse_whitespace() {
    assert_eq!(parse("   "), None);
}

#[test]
fn test_parse_valid() {
    assert_eq!(parse("hello"), Some("hello"));
}
```

After (good):

```rust
#[rstest]
#[case::empty("", None)]
#[case::whitespace("   ", None)]
#[case::valid("hello", Some("hello"))]
fn test_parse(#[case] input: &str, #[case] expected: Option<&str>) {
    assert_eq!(parse(input), expected);
}
```

### Do not write tests that only verify test helpers

Test code should verify production (non-test) code behavior. Tests that only exercise test helper functions, fixtures, or test utilities are unnecessary and add maintenance burden without improving confidence in production code.

Signs of violation:

- A test function whose only assertions target a helper function defined in the test module or test utilities
- Tests named like `test_make_fixture`, `test_create_mock`, `test_build_test_data` that verify the correctness of setup/helper functions used by other tests
- Tests whose sole purpose is to assert that a builder, factory, or fake returns expected default values

Suggested fix:

- Remove the test entirely. If the helper is complex enough to need its own tests, consider whether it should be promoted to production code with its own proper test suite
- Trust that test helpers are validated indirectly by the tests that use them â€” if a helper is broken, the tests depending on it will fail

### Use `#[fixture]` for shared test setup

When multiple test functions repeat the same setup code, extract it into an rstest `#[fixture]`.

Signs of violation:

- Identical `let` bindings or initialization blocks at the top of multiple test functions
- Builder/constructor calls repeated across tests with the same arguments

Before (bad):

```rust
#[rstest]
fn test_find_existing(/* ... */) {
    let mut repo = InMemoryRepository::default();
    repo.add(item);
    // ...
}

#[rstest]
fn test_find_missing(/* ... */) {
    let mut repo = InMemoryRepository::default();
    repo.add(item);
    // ...
}
```

After (good):

```rust
#[fixture]
fn repository() -> InMemoryRepository {
    let mut r = InMemoryRepository::default();
    r.add(item);
    r
}

#[rstest]
fn test_find_existing(repository: InMemoryRepository) { /* ... */ }

#[rstest]
fn test_find_missing(repository: InMemoryRepository) { /* ... */ }
```

### Always name `#[case]` variants

Use `#[case::descriptive_name(...)]` instead of bare `#[case(...)]`. Named cases make test failure output immediately understandable without inspecting the input values.

Before (bad):

```rust
#[rstest]
#[case("", None)]
#[case("hello", Some("hello"))]
fn test_parse(#[case] input: &str, #[case] expected: Option<&str>) { /* ... */ }
```

After (good):

```rust
#[rstest]
#[case::empty("", None)]
#[case::valid("hello", Some("hello"))]
fn test_parse(#[case] input: &str, #[case] expected: Option<&str>) { /* ... */ }
```

### Extract repeated assertion patterns into helper functions

When multiple test functions contain the same sequence of assertions or complex validation logic, extract it into a shared helper function.

Signs of violation:

- The same `assert_eq!` / `assert!` chain appears in 3+ test functions
- Multi-line assertion logic (e.g., destructure then assert each field) is copy-pasted across tests

Before (bad):

```rust
#[rstest]
fn test_parse_markdown(/* ... */) {
    let doc = parse(input);
    assert_eq!(doc.title, expected_title);
    assert_eq!(doc.body, expected_body);
    assert!(doc.metadata.is_some());
}

#[rstest]
fn test_parse_html(/* ... */) {
    let doc = parse(input);
    assert_eq!(doc.title, expected_title);
    assert_eq!(doc.body, expected_body);
    assert!(doc.metadata.is_some());
}
```

After (good):

```rust
fn assert_doc(doc: &Document, expected_title: &str, expected_body: &str) {
    assert_eq!(doc.title, expected_title);
    assert_eq!(doc.body, expected_body);
    assert!(doc.metadata.is_some());
}

#[rstest]
fn test_parse_markdown(/* ... */) {
    assert_doc(&parse(input), expected_title, expected_body);
}
```
{% endif -%}
